#!/usr/bin/env julia

# Add the current directory to the load path
push!(LOAD_PATH, @__DIR__)

using Logging
using Dates
using HTTP
using JSON
using Sockets
using Base.Threads

# Create a simple logger for initialization before loading JuliaOS
struct SimpleFileLogger <: AbstractLogger
    stream::IO
    min_level::LogLevel
end

function Logging.handle_message(logger::SimpleFileLogger, level, message, _module, group, id, file, line; kwargs...)
    if level >= logger.min_level
        timestamp = Dates.format(now(), "yyyy-mm-dd HH:MM:SS")
        println(logger.stream, "[$timestamp] [$level] $message")
        for (key, val) in kwargs
            println(logger.stream, "  $key = $val")
        end
        flush(logger.stream)
    end
    return nothing
end

Logging.min_enabled_level(logger::SimpleFileLogger) = logger.min_level
Logging.shouldlog(logger::SimpleFileLogger, level, _module, group, id) = level >= logger.min_level

# Configure logging
log_dir = joinpath(@__DIR__, "logs")
mkpath(log_dir)
log_file = joinpath(log_dir, "juliaos_$(Dates.format(now(), "yyyy-mm-dd_HH-MM-SS")).log")
file_logger = SimpleFileLogger(open(log_file, "w"), Logging.Info)
global_logger(file_logger)

# Create logs directory if it doesn't exist
mkpath(joinpath(@__DIR__, "logs"))

@info "Starting JuliaOS server..."

# Precompilation setup
precompile_cache_dir = joinpath(@__DIR__, "precompile_cache")
mkpath(precompile_cache_dir)
precompile_directives_file = joinpath(precompile_cache_dir, "precompile_directives.jl")

# Create precompilation directives if they don't exist
if !isfile(precompile_directives_file)
    @info "Creating precompilation directives..."
    open(precompile_directives_file, "w") do io
        write(io, """
        # Precompilation directives for JuliaOS
        # This file is automatically generated

        # Precompile core modules
        precompile(Tuple{typeof(Base.include), Module, String})
        precompile(Tuple{typeof(JSON.parse), String})
        precompile(Tuple{typeof(JSON.json), Dict{String, Any}})

        # Precompile HTTP server functions
        precompile(Tuple{typeof(HTTP.listen), String, Int})
        precompile(Tuple{typeof(HTTP.Response), Int, Dict{String, String}, String})

        # Precompile command handler functions
        precompile(Tuple{typeof(JuliaOS.CommandHandler.handle_command), String, Dict{String, Any}})
        """)
    end
    @info "Precompilation directives created"
end

# Load precompilation directives
@info "Loading precompilation directives from cache..."
try
    include(precompile_directives_file)
    @info "Precompilation directives loaded"
catch e
    @warn "Error loading precompilation directives: $e"
    @warn "Continuing without precompilation directives"
end

# Load configuration
include("../config/config.jl")
config = Config.load()

# Import modules
include("../src/juliaos.jl")
# Metrics module is not available yet
# include("../src/core/utils/Metrics.jl")

# Use the CommandHandler module from JuliaOS
# The command handler is now included in the JuliaOS module

using .JuliaOS
# using .Metrics

# Initialize console logging
console_logger = SimpleFileLogger(stdout, Logging.Info)
global_logger(console_logger)

# Global state
const GLOBAL_STATE = Dict{String, Any}(
    "server_start_time" => now(),
    "requests_handled" => 0,
    "last_error" => nothing
)

# Command registry
const COMMANDS = Dict{String, Function}(
    # System commands
    # "system.health" => () -> JuliaOS.check_system_health(), # Moved to server.jl handle_command

    # Metrics commands
    # "metrics.get_system_overview" => () -> Metrics.get_system_overview(), # Moved to server.jl handle_command
    # "metrics.get_realtime_metrics" => () -> Metrics.get_realtime_metrics(), # Moved to server.jl handle_command
    # "metrics.get_resource_usage" => () -> Metrics.get_resource_usage(), # Moved to server.jl handle_command
    # "metrics.run_performance_test" => () -> Metrics.run_performance_test(), # Moved to server.jl handle_command

    # ... existing commands ...
)

try
    # Initialize the system
    @info "Initializing JuliaOS system..."
    init_success = JuliaOS.initialize()

    if init_success
        @info "JuliaOS system initialized successfully"
    else
        @error "Failed to initialize JuliaOS system"
        exit(1)
    end

    # Print initialization information
    @info "JuliaOS initialized with the following components:"
    @info "- Storage: $(config.storage.local_db_path)"
    @info "- Server: $(config.server.host):$(config.server.port)"

    # Check if Python wrapper is available
    if JuliaOS.PYTHON_WRAPPER_EXISTS
        @info "- Python wrapper: Available"
    else
        @info "- Python wrapper: Not available"
    end

    # Check if framework is available
    if JuliaOS.FRAMEWORK_EXISTS
        @info "- Framework: Available"
    else
        @info "- Framework: Not available"
    end

    # Start the server
    @info "Starting HTTP server on $(config.server.host):$(config.server.port)"

    # Check if API.Server module exists
    if isdefined(JuliaOS, :API) && isdefined(JuliaOS.API, :Server)
        server_started = JuliaOS.API.Server.start_server(config.server.host, config.server.port)
        if !server_started
            @error "JuliaOS.API.Server.start_server failed to start the server. Exiting."
            exit(1)
        end
        @info "Server started successfully"

        # Keep the script running
        while JuliaOS.API.Server.is_running
            sleep(1)
        end
    else
        # Fallback to a simple HTTP server if Server module is not available
        @warn "JuliaOS.API.Server module not available. Starting simple HTTP server."

        # Create a simple HTTP server
        router = HTTP.Router()

        # Add a health check endpoint
        HTTP.register!(router, "GET", "/health", function(req)
            health_data = Dict(
                "status" => "healthy",
                "timestamp" => string(now()),
                "version" => "1.0.0",
                "components" => Dict(
                    "storage" => Dict("status" => "healthy"),
                    "server" => Dict("status" => "healthy"),
                    "framework" => Dict("status" => "healthy")
                ),
                "uptime_seconds" => Dates.value(now() - GLOBAL_STATE["server_start_time"]) / 1000
            )
            return HTTP.Response(200, ["Content-Type" => "application/json"], JSON.json(health_data))
        end)

        # Add an error endpoint to get the last error
        HTTP.register!(router, "GET", "/error", function(req)
            last_error = get(GLOBAL_STATE, "last_error", nothing)
            if last_error === nothing
                return HTTP.Response(200, ["Content-Type" => "application/json"], "{\"status\": \"ok\", \"message\": \"No errors recorded\", \"timestamp\": \"$(now())\"}")
            else
                return HTTP.Response(200, ["Content-Type" => "application/json"], JSON.json(Dict(
                    "status" => "error",
                    "last_error" => last_error,
                    "timestamp" => now()
                )))
            end
        end)

        # Add a stats endpoint to get server statistics
        HTTP.register!(router, "GET", "/stats", function(req)
            # Increment the request counter
            GLOBAL_STATE["requests_handled"] += 1

            # Calculate uptime
            uptime_seconds = Dates.value(now() - GLOBAL_STATE["server_start_time"]) / 1000

            # Get system metrics
            metrics = Dict(
                "uptime_seconds" => uptime_seconds,
                "requests_handled" => GLOBAL_STATE["requests_handled"],
                "server_start_time" => GLOBAL_STATE["server_start_time"],
                "current_time" => now()
            )

            # Try to get additional metrics from JuliaOS.Metrics if available
            try
                if isdefined(JuliaOS, :Core) && isdefined(JuliaOS.Core, :Utils) && isdefined(JuliaOS.Core.Utils, :Metrics)
                    system_metrics = JuliaOS.Core.Utils.Metrics.get_system_overview()
                    for (k, v) in system_metrics
                        metrics[k] = v
                    end
                end
            catch e
                @warn "Error getting system metrics" exception=(e, catch_backtrace())
            end

            return HTTP.Response(200, ["Content-Type" => "application/json"], JSON.json(metrics))
        end)

        # Add an API endpoint
        HTTP.register!(router, "POST", "/api", function(req)
            try
                # Parse the request body
                body_str = String(req.body)
                @info "Received API request: $body_str"

                body = JSON.parse(body_str)
                command = get(body, "command", "")
                params = get(body, "params", Dict())

                @info "Received command: $command with params: $params"

                # Extract command from URL if not in body (for enhanced-bridge.js)
                if isempty(command)
                    # Try to extract command from URL path
                    path_parts = split(req.target, "/")
                    if length(path_parts) > 2 && path_parts[end] != ""
                        command = path_parts[end]
                        @info "Extracted command from URL: $command"
                    else
                        return HTTP.Response(400, ["Content-Type" => "application/json"], "{\"success\": false, \"error\": \"Missing command parameter\"}")
                    end
                end

                # Handle special case for create_agent command (from enhanced-bridge.js)
                if command == "create_agent"
                    @info "Converting create_agent to agents.create_agent"
                    command = "agents.create_agent"
                end

                # Special case for agents.create_agent command
                if command == "agents.create_agent"
                    @info "Handling agents.create_agent command directly"
                    # Check if required parameters are provided
                    name = get(params, "name", nothing)
                    agent_type = get(params, "type", "CUSTOM")

                    if isnothing(name)
                        error_response = Dict("success" => false, "error" => "Missing required parameter: name")
                        return HTTP.Response(400, ["Content-Type" => "application/json"], JSON.json(error_response))
                    end

                    # Check if Agents module is available
                    if isdefined(JuliaOS, :Agents) && isdefined(JuliaOS.Agents, :createAgent) && isdefined(JuliaOS.Agents, :AgentConfig) && isdefined(JuliaOS.Agents, :AgentType)
                        @info "Using JuliaOS.Agents.createAgent"

                        # Convert string type to enum
                        agent_type_enum = JuliaOS.Agents.CUSTOM # Default to CUSTOM
                        try
                            if isa(agent_type, String)
                                agent_type_enum = getfield(JuliaOS.Agents, Symbol(uppercase(agent_type)))
                            elseif isa(agent_type, Integer)
                                agent_type_enum = JuliaOS.Agents.AgentType(agent_type)
                            end
                        catch e
                            @warn "Invalid agent type: $agent_type, using CUSTOM" exception=e
                        end

                        # Get additional parameters
                        abilities = String[]
                        if haskey(params, "abilities")
                            # Convert Any[] to String[]
                            for ability in params["abilities"]
                                push!(abilities, string(ability))
                            end
                        end

                        chains = String[]
                        if haskey(params, "chains")
                            # Convert Any[] to String[]
                            for chain in params["chains"]
                                push!(chains, string(chain))
                            end
                        end

                        parameters = get(params, "parameters", Dict{String,Any}())
                        llm_config = get(params, "llm_config", Dict{String,Any}())
                        memory_config = get(params, "memory_config", Dict{String,Any}())
                        max_task_history = get(params, "max_task_history", 100)

                        # Create agent config
                        config = JuliaOS.Agents.AgentConfig(
                            name,
                            agent_type_enum;
                            abilities=abilities,
                            chains=chains,
                            parameters=parameters,
                            llm_config=llm_config,
                            memory_config=memory_config,
                            max_task_history=max_task_history
                        )

                        # Create the agent
                        agent = JuliaOS.Agents.createAgent(config)

                        # Format the response
                        result = Dict(
                            "success" => true,
                            "data" => Dict(
                                "id" => agent.id,
                                "name" => agent.name,
                                "type" => Int(agent.type),
                                "status" => Int(agent.status),
                                "created" => string(agent.created),
                                "updated" => string(agent.updated)
                            )
                        )

                        return HTTP.Response(200, ["Content-Type" => "application/json"], JSON.json(result))
                    else
                        @warn "JuliaOS.Agents module not available or createAgent not defined, using mock implementation"
                        # Mock implementation for create_agent
                        agent_id = "agent-" * randstring(8)
                        result = Dict(
                            "success" => true,
                            "data" => Dict(
                                "id" => agent_id,
                                "name" => name,
                                "type" => isa(agent_type, Integer) ? agent_type : 99, # CUSTOM = 99
                                "status" => 1, # CREATED = 1
                                "created" => string(now()),
                                "updated" => string(now())
                            )
                        )
                        return HTTP.Response(200, ["Content-Type" => "application/json"], JSON.json(result))
                    end
                end

                # Special case for system.ping command
                if command == "system.ping"
                    @info "Handling system.ping command directly"
                    ping_response = Dict(
                        "success" => true,
                        "data" => Dict(
                            "message" => "pong",
                            "timestamp" => string(now())
                        )
                    )
                    return HTTP.Response(200, ["Content-Type" => "application/json"], JSON.json(ping_response))
                end

                # Special case for metrics.get_system_overview command
                if command == "metrics.get_system_overview"
                    @info "Handling metrics.get_system_overview command directly"
                    # Create a mock system overview
                    system_overview = Dict(
                        "cpu_usage" => Dict(
                            "percent" => 25.5,
                            "cores" => 8,
                            "threads" => 16
                        ),
                        "memory_usage" => Dict(
                            "total" => 16384,  # MB
                            "used" => 4096,    # MB
                            "percent" => 25.0
                        ),
                        "storage" => Dict(
                            "total" => 512000,  # MB
                            "used" => 128000,   # MB
                            "percent" => 25.0
                        ),
                        "uptime" => Dict(
                            "seconds" => 3600,
                            "formatted" => "1 hour"
                        ),
                        "active_agents" => 2,
                        "active_swarms" => 1,
                        "pending_tasks" => 0,
                        "timestamp" => string(now())
                    )

                    metrics_response = Dict(
                        "success" => true,
                        "data" => system_overview
                    )

                    return HTTP.Response(200, ["Content-Type" => "application/json"], JSON.json(metrics_response))
                end

                # Special case for algorithms.list_algorithms command
                if command == "algorithms.list_algorithms"
                    @info "Handling algorithms.list_algorithms command directly"
                    # Check if Algorithms module is available
                    if isdefined(JuliaOS, :Algorithms) && isdefined(JuliaOS.Algorithms, :list_algorithms)
                        @info "Using JuliaOS.Algorithms.list_algorithms"
                        result = JuliaOS.Algorithms.list_algorithms()
                        return HTTP.Response(200, ["Content-Type" => "application/json"], JSON.json(result))
                    else
                        @warn "JuliaOS.Algorithms module not available, using mock implementation"
                        # Mock implementation for list_algorithms
                        algorithms = [
                            Dict("id" => "differential_evolution", "name" => "Differential Evolution", "type" => "global_optimization"),
                            Dict("id" => "particle_swarm", "name" => "Particle Swarm Optimization", "type" => "global_optimization"),
                            Dict("id" => "genetic_algorithm", "name" => "Genetic Algorithm", "type" => "global_optimization"),
                            Dict("id" => "simulated_annealing", "name" => "Simulated Annealing", "type" => "global_optimization"),
                            Dict("id" => "nelder_mead", "name" => "Nelder-Mead", "type" => "local_optimization"),
                            Dict("id" => "bfgs", "name" => "BFGS", "type" => "local_optimization"),
                            Dict("id" => "gradient_descent", "name" => "Gradient Descent", "type" => "local_optimization"),
                            Dict("id" => "newton", "name" => "Newton's Method", "type" => "local_optimization")
                        ]
                        result = Dict("success" => true, "data" => Dict("algorithms" => algorithms))
                        return HTTP.Response(200, ["Content-Type" => "application/json"], JSON.json(result))
                    end
                end

                # Special case for algorithms.get_test_functions command
                if command == "algorithms.get_test_functions"
                    @info "Handling algorithms.get_test_functions command directly"
                    # Mock implementation for get_test_functions
                    test_functions = [
                        Dict("id" => "sphere", "name" => "Sphere", "dimensions" => "n", "description" => "Simple quadratic function"),
                        Dict("id" => "rosenbrock", "name" => "Rosenbrock", "dimensions" => "n", "description" => "Non-convex function with a narrow valley"),
                        Dict("id" => "rastrigin", "name" => "Rastrigin", "dimensions" => "n", "description" => "Highly multimodal function"),
                        Dict("id" => "ackley", "name" => "Ackley", "dimensions" => "n", "description" => "Function with many local minima"),
                        Dict("id" => "griewank", "name" => "Griewank", "dimensions" => "n", "description" => "Function with many local minima")
                    ]

                    result = Dict("success" => true, "data" => Dict("test_functions" => test_functions))
                    return HTTP.Response(200, ["Content-Type" => "application/json"], JSON.json(result))
                end

                # Special case for swarm algorithm commands
                if command == "swarm.list_algorithms" || command == "Swarm.get_available_algorithms"
                    @info "Handling swarm algorithm command directly: $command"
                    # Check if Swarms module is available
                    if isdefined(JuliaOS, :Swarms) && isdefined(JuliaOS.Swarms, :list_algorithms)
                        @info "Using JuliaOS.Swarms.list_algorithms"
                        result = JuliaOS.Swarms.list_algorithms()
                        return HTTP.Response(200, ["Content-Type" => "application/json"], JSON.json(result))
                    else
                        @warn "JuliaOS.Swarms module not available, using mock implementation"
                        # Mock implementation for list_algorithms
                        algorithms = [
                            Dict(
                                "id" => "PSO",
                                "name" => "Particle Swarm Optimization",
                                "description" => "A population-based optimization technique inspired by social behavior of bird flocking or fish schooling.",
                                "parameters" => [
                                    Dict("name" => "population_size", "type" => "integer", "default" => 50, "description" => "Number of particles in the swarm"),
                                    Dict("name" => "max_iterations", "type" => "integer", "default" => 100, "description" => "Maximum number of iterations"),
                                    Dict("name" => "c1", "type" => "float", "default" => 2.0, "description" => "Cognitive parameter"),
                                    Dict("name" => "c2", "type" => "float", "default" => 2.0, "description" => "Social parameter"),
                                    Dict("name" => "w", "type" => "float", "default" => 0.7, "description" => "Inertia weight")
                                ]
                            ),
                            Dict(
                                "id" => "GA",
                                "name" => "Genetic Algorithm",
                                "description" => "A search heuristic that mimics the process of natural selection.",
                                "parameters" => [
                                    Dict("name" => "population_size", "type" => "integer", "default" => 100, "description" => "Number of individuals in the population"),
                                    Dict("name" => "max_generations", "type" => "integer", "default" => 100, "description" => "Maximum number of generations"),
                                    Dict("name" => "crossover_rate", "type" => "float", "default" => 0.8, "description" => "Probability of crossover"),
                                    Dict("name" => "mutation_rate", "type" => "float", "default" => 0.1, "description" => "Probability of mutation")
                                ]
                            ),
                            Dict(
                                "id" => "ACO",
                                "name" => "Ant Colony Optimization",
                                "description" => "A probabilistic technique for solving computational problems which can be reduced to finding good paths through graphs.",
                                "parameters" => [
                                    Dict("name" => "num_ants", "type" => "integer", "default" => 50, "description" => "Number of ants"),
                                    Dict("name" => "max_iterations", "type" => "integer", "default" => 100, "description" => "Maximum number of iterations"),
                                    Dict("name" => "alpha", "type" => "float", "default" => 1.0, "description" => "Pheromone importance"),
                                    Dict("name" => "beta", "type" => "float", "default" => 2.0, "description" => "Heuristic importance"),
                                    Dict("name" => "rho", "type" => "float", "default" => 0.5, "description" => "Pheromone evaporation rate")
                                ]
                            ),
                            Dict(
                                "id" => "DE",
                                "name" => "Differential Evolution",
                                "description" => "A stochastic population-based optimization algorithm for solving over-continuous spaces.",
                                "parameters" => [
                                    Dict("name" => "population_size", "type" => "integer", "default" => 50, "description" => "Number of individuals in the population"),
                                    Dict("name" => "max_generations", "type" => "integer", "default" => 100, "description" => "Maximum number of generations"),
                                    Dict("name" => "F", "type" => "float", "default" => 0.8, "description" => "Differential weight"),
                                    Dict("name" => "CR", "type" => "float", "default" => 0.9, "description" => "Crossover probability")
                                ]
                            ),
                            Dict(
                                "id" => "GWO",
                                "name" => "Grey Wolf Optimizer",
                                "description" => "A meta-heuristic algorithm inspired by the leadership hierarchy and hunting mechanism of grey wolves.",
                                "parameters" => [
                                    Dict("name" => "population_size", "type" => "integer", "default" => 30, "description" => "Number of wolves in the pack"),
                                    Dict("name" => "max_iterations", "type" => "integer", "default" => 100, "description" => "Maximum number of iterations")
                                ]
                            ),
                            Dict(
                                "id" => "WOA",
                                "name" => "Whale Optimization Algorithm",
                                "description" => "A nature-inspired meta-heuristic optimization algorithm that mimics the hunting behavior of humpback whales.",
                                "parameters" => [
                                    Dict("name" => "population_size", "type" => "integer", "default" => 30, "description" => "Number of whales"),
                                    Dict("name" => "max_iterations", "type" => "integer", "default" => 100, "description" => "Maximum number of iterations")
                                ]
                            ),
                            Dict(
                                "id" => "DEPSO",
                                "name" => "Differential Evolution Particle Swarm Optimization",
                                "description" => "A hybrid algorithm that combines Differential Evolution and Particle Swarm Optimization.",
                                "parameters" => [
                                    Dict("name" => "population_size", "type" => "integer", "default" => 50, "description" => "Number of individuals in the population"),
                                    Dict("name" => "max_iterations", "type" => "integer", "default" => 100, "description" => "Maximum number of iterations"),
                                    Dict("name" => "c1", "type" => "float", "default" => 2.0, "description" => "Cognitive parameter"),
                                    Dict("name" => "c2", "type" => "float", "default" => 2.0, "description" => "Social parameter"),
                                    Dict("name" => "w", "type" => "float", "default" => 0.7, "description" => "Inertia weight"),
                                    Dict("name" => "F", "type" => "float", "default" => 0.8, "description" => "Differential weight"),
                                    Dict("name" => "CR", "type" => "float", "default" => 0.9, "description" => "Crossover probability")
                                ]
                            )
                        ]

                        result = Dict("success" => true, "data" => Dict("algorithms" => algorithms))
                        return HTTP.Response(200, ["Content-Type" => "application/json"], JSON.json(result))
                    end
                end

                # Special case for dex.list_dexes command
                if command == "dex.list_dexes"
                    @info "Handling dex.list_dexes command directly"
                    # Check if DEX module is available
                    if isdefined(JuliaOS, :DEX) && isdefined(JuliaOS.DEX, :list_dexes)
                        @info "Using JuliaOS.DEX.list_dexes"
                        result = JuliaOS.DEX.list_dexes()
                        return HTTP.Response(200, ["Content-Type" => "application/json"], JSON.json(result))
                    else
                        @warn "JuliaOS.DEX module not available or list_dexes not defined, using mock implementation"
                        # Mock implementation for list_dexes
                        dexes = [
                            Dict("id" => "uniswap", "name" => "Uniswap V3", "chain" => "ethereum", "type" => "amm"),
                            Dict("id" => "sushiswap", "name" => "SushiSwap", "chain" => "ethereum", "type" => "amm"),
                            Dict("id" => "pancakeswap", "name" => "PancakeSwap", "chain" => "bsc", "type" => "amm"),
                            Dict("id" => "raydium", "name" => "Raydium", "chain" => "solana", "type" => "amm"),
                            Dict("id" => "curve", "name" => "Curve", "chain" => "ethereum", "type" => "stableswap"),
                            Dict("id" => "balancer", "name" => "Balancer", "chain" => "ethereum", "type" => "weighted"),
                            Dict("id" => "trader_joe", "name" => "Trader Joe", "chain" => "avalanche", "type" => "amm"),
                            Dict("id" => "quickswap", "name" => "QuickSwap", "chain" => "polygon", "type" => "amm"),
                            Dict("id" => "dydx", "name" => "dYdX", "chain" => "ethereum", "type" => "derivatives"),
                            Dict("id" => "gmx", "name" => "GMX", "chain" => "arbitrum", "type" => "derivatives")
                        ]

                        result = Dict("success" => true, "data" => Dict("dexes" => dexes))
                        return HTTP.Response(200, ["Content-Type" => "application/json"], JSON.json(result))
                    end
                end

                # Special case for dex.list_aggregators command
                if command == "dex.list_aggregators"
                    @info "Handling dex.list_aggregators command directly"
                    # Check if DEX module is available
                    if isdefined(JuliaOS, :DEX) && isdefined(JuliaOS.DEX, :list_aggregators)
                        @info "Using JuliaOS.DEX.list_aggregators"
                        result = JuliaOS.DEX.list_aggregators()
                        return HTTP.Response(200, ["Content-Type" => "application/json"], JSON.json(result))
                    else
                        @warn "JuliaOS.DEX module not available or list_aggregators not defined, using mock implementation"
                        # Mock implementation for list_aggregators
                        aggregators = [
                            Dict("id" => "1inch", "name" => "1inch", "chains" => ["ethereum", "bsc", "polygon", "arbitrum", "optimism"]),
                            Dict("id" => "0x", "name" => "0x Protocol", "chains" => ["ethereum", "bsc", "polygon", "avalanche"]),
                            Dict("id" => "paraswap", "name" => "ParaSwap", "chains" => ["ethereum", "bsc", "polygon", "avalanche"]),
                            Dict("id" => "matcha", "name" => "Matcha", "chains" => ["ethereum", "bsc", "polygon"]),
                            Dict("id" => "openocean", "name" => "OpenOcean", "chains" => ["ethereum", "bsc", "polygon", "solana"]),
                            Dict("id" => "kyber", "name" => "Kyber Network", "chains" => ["ethereum", "bsc", "polygon", "avalanche"]),
                            Dict("id" => "jupiter", "name" => "Jupiter", "chains" => ["solana"])
                        ]

                        result = Dict("success" => true, "data" => Dict("aggregators" => aggregators))
                        return HTTP.Response(200, ["Content-Type" => "application/json"], JSON.json(result))
                    end
                end

                # Special case for wallets.list_wallets command
                if command == "wallets.list_wallets"
                    @info "Handling wallets.list_wallets command directly"
                    # Check if Wallets module is available
                    if isdefined(JuliaOS, :Wallets) && isdefined(JuliaOS.Wallets, :listWallets)
                        @info "Using JuliaOS.Wallets.listWallets"
                        result = JuliaOS.Wallets.listWallets()
                        return HTTP.Response(200, ["Content-Type" => "application/json"], JSON.json(result))
                    else
                        @warn "JuliaOS.Wallets module not available or listWallets not defined, using mock implementation"
                        # Mock implementation for list_wallets
                        wallets = [
                            Dict("id" => "wallet1", "name" => "Main Wallet", "type" => "ethereum", "address" => "0x1234...5678"),
                            Dict("id" => "wallet2", "name" => "Solana Wallet", "type" => "solana", "address" => "ABC...XYZ")
                        ]

                        result = Dict("success" => true, "data" => Dict("wallets" => wallets))
                        return HTTP.Response(200, ["Content-Type" => "application/json"], JSON.json(result))
                    end
                end

                # Special case for agents.list_agents command
                if command == "agents.list_agents"
                    @info "Handling agents.list_agents command directly"
                    # Check if Agents module is available
                    if isdefined(JuliaOS, :Agents) && isdefined(JuliaOS.Agents, :listAgents)
                        @info "Using JuliaOS.Agents.listAgents"
                        agents = JuliaOS.Agents.listAgents()

                        # Apply filters if specified
                        if haskey(params, "type")
                            agents = filter(a -> a["type"] == params["type"], agents)
                        end

                        if haskey(params, "status")
                            agents = filter(a -> a["status"] == params["status"], agents)
                        end

                        # Apply sorting
                        if haskey(params, "order_by") && params["order_by"] in ["created_at", "name", "status", "type"]
                            order_column = params["order_by"]
                            order_direction = get(params, "order_direction", "asc")

                            # Sort the agents
                            if lowercase(order_direction) == "asc"
                                sort!(agents, by = a -> a[order_column])
                            else
                                sort!(agents, by = a -> a[order_column], rev = true)
                            end
                        end

                        # Apply pagination
                        limit = get(params, "limit", 100)
                        offset = get(params, "offset", 0)

                        # Ensure limit and offset are reasonable
                        limit = min(max(1, limit), 1000)  # Between 1 and 1000
                        offset = max(0, offset)           # At least 0

                        # Get total count before pagination
                        total = length(agents)

                        # Apply pagination
                        if offset < total
                            end_idx = min(offset + limit, total)
                            agents = agents[offset+1:end_idx]
                        else
                            agents = []
                        end

                        # Create the response
                        result = Dict(
                            "success" => true,
                            "data" => Dict(
                                "agents" => agents,
                                "pagination" => Dict(
                                    "total" => total,
                                    "limit" => limit,
                                    "offset" => offset
                                )
                            )
                        )

                        return HTTP.Response(200, ["Content-Type" => "application/json"], JSON.json(result))
                    else
                        @warn "JuliaOS.AgentSystem module not available or list_agents not defined, using mock implementation"
                        # Mock implementation for list_agents
                        agents = [
                            Dict("id" => "agent1", "name" => "Trading Agent", "type" => "trading", "status" => "active", "created_at" => string(now() - Dates.Day(10))),
                            Dict("id" => "agent2", "name" => "Data Agent", "type" => "data", "status" => "inactive", "created_at" => string(now() - Dates.Day(5)))
                        ]

                        # Create the response
                        result = Dict(
                            "success" => true,
                            "data" => Dict(
                                "agents" => agents,
                                "pagination" => Dict(
                                    "total" => 2,
                                    "limit" => 100,
                                    "offset" => 0
                                )
                            )
                        )

                        return HTTP.Response(200, ["Content-Type" => "application/json"], JSON.json(result))
                    end
                end

                # Special case for agents.start_agent command
                if command == "agents.start_agent"
                    @info "Handling agents.start_agent command directly"
                    # Check if required parameters are provided
                    agent_id = get(params, "agent_id", nothing)

                    if isnothing(agent_id)
                        error_response = Dict("success" => false, "error" => "Missing required parameter: agent_id")
                        return HTTP.Response(400, ["Content-Type" => "application/json"], JSON.json(error_response))
                    end

                    # Check if Agents module is available
                    if isdefined(JuliaOS, :Agents) && isdefined(JuliaOS.Agents, :startAgent)
                        @info "Using JuliaOS.Agents.startAgent"
                        success = JuliaOS.Agents.startAgent(agent_id)

                        if success
                            result = Dict(
                                "success" => true,
                                "data" => Dict(
                                    "agent_id" => agent_id,
                                    "status" => "started"
                                )
                            )
                            return HTTP.Response(200, ["Content-Type" => "application/json"], JSON.json(result))
                        else
                            error_response = Dict("success" => false, "error" => "Failed to start agent: $agent_id")
                            return HTTP.Response(500, ["Content-Type" => "application/json"], JSON.json(error_response))
                        end
                    else
                        @warn "JuliaOS.Agents module not available or startAgent not defined, using mock implementation"
                        # Mock implementation for start_agent
                        result = Dict(
                            "success" => true,
                            "data" => Dict(
                                "agent_id" => agent_id,
                                "status" => "started"
                            )
                        )
                        return HTTP.Response(200, ["Content-Type" => "application/json"], JSON.json(result))
                    end
                end

                # Special case for agents.stop_agent command
                if command == "agents.stop_agent"
                    @info "Handling agents.stop_agent command directly"
                    # Check if required parameters are provided
                    agent_id = get(params, "agent_id", nothing)

                    if isnothing(agent_id)
                        error_response = Dict("success" => false, "error" => "Missing required parameter: agent_id")
                        return HTTP.Response(400, ["Content-Type" => "application/json"], JSON.json(error_response))
                    end

                    # Check if Agents module is available
                    if isdefined(JuliaOS, :Agents) && isdefined(JuliaOS.Agents, :stopAgent)
                        @info "Using JuliaOS.Agents.stopAgent"
                        success = JuliaOS.Agents.stopAgent(agent_id)

                        if success
                            result = Dict(
                                "success" => true,
                                "data" => Dict(
                                    "agent_id" => agent_id,
                                    "status" => "stopped"
                                )
                            )
                            return HTTP.Response(200, ["Content-Type" => "application/json"], JSON.json(result))
                        else
                            error_response = Dict("success" => false, "error" => "Failed to stop agent: $agent_id")
                            return HTTP.Response(500, ["Content-Type" => "application/json"], JSON.json(error_response))
                        end
                    else
                        @warn "JuliaOS.Agents module not available or stopAgent not defined, using mock implementation"
                        # Mock implementation for stop_agent
                        result = Dict(
                            "success" => true,
                            "data" => Dict(
                                "agent_id" => agent_id,
                                "status" => "stopped"
                            )
                        )
                        return HTTP.Response(200, ["Content-Type" => "application/json"], JSON.json(result))
                    end
                end

                # Special case for agents.pause_agent command
                if command == "agents.pause_agent"
                    @info "Handling agents.pause_agent command directly"
                    # Check if required parameters are provided
                    agent_id = get(params, "agent_id", nothing)

                    if isnothing(agent_id)
                        error_response = Dict("success" => false, "error" => "Missing required parameter: agent_id")
                        return HTTP.Response(400, ["Content-Type" => "application/json"], JSON.json(error_response))
                    end

                    # Check if Agents module is available
                    if isdefined(JuliaOS, :Agents) && isdefined(JuliaOS.Agents, :pauseAgent)
                        @info "Using JuliaOS.Agents.pauseAgent"
                        success = JuliaOS.Agents.pauseAgent(agent_id)

                        if success
                            result = Dict(
                                "success" => true,
                                "data" => Dict(
                                    "agent_id" => agent_id,
                                    "status" => "paused"
                                )
                            )
                            return HTTP.Response(200, ["Content-Type" => "application/json"], JSON.json(result))
                        else
                            error_response = Dict("success" => false, "error" => "Failed to pause agent: $agent_id")
                            return HTTP.Response(500, ["Content-Type" => "application/json"], JSON.json(error_response))
                        end
                    else
                        @warn "JuliaOS.Agents module not available or pauseAgent not defined, using mock implementation"
                        # Mock implementation for pause_agent
                        result = Dict(
                            "success" => true,
                            "data" => Dict(
                                "agent_id" => agent_id,
                                "status" => "paused"
                            )
                        )
                        return HTTP.Response(200, ["Content-Type" => "application/json"], JSON.json(result))
                    end
                end

                # Special case for agents.resume_agent command
                if command == "agents.resume_agent"
                    @info "Handling agents.resume_agent command directly"
                    # Check if required parameters are provided
                    agent_id = get(params, "agent_id", nothing)

                    if isnothing(agent_id)
                        error_response = Dict("success" => false, "error" => "Missing required parameter: agent_id")
                        return HTTP.Response(400, ["Content-Type" => "application/json"], JSON.json(error_response))
                    end

                    # Check if Agents module is available
                    if isdefined(JuliaOS, :Agents) && isdefined(JuliaOS.Agents, :resumeAgent)
                        @info "Using JuliaOS.Agents.resumeAgent"
                        success = JuliaOS.Agents.resumeAgent(agent_id)

                        if success
                            result = Dict(
                                "success" => true,
                                "data" => Dict(
                                    "agent_id" => agent_id,
                                    "status" => "resumed"
                                )
                            )
                            return HTTP.Response(200, ["Content-Type" => "application/json"], JSON.json(result))
                        else
                            error_response = Dict("success" => false, "error" => "Failed to resume agent: $agent_id")
                            return HTTP.Response(500, ["Content-Type" => "application/json"], JSON.json(error_response))
                        end
                    else
                        @warn "JuliaOS.Agents module not available or resumeAgent not defined, using mock implementation"
                        # Mock implementation for resume_agent
                        result = Dict(
                            "success" => true,
                            "data" => Dict(
                                "agent_id" => agent_id,
                                "status" => "resumed"
                            )
                        )
                        return HTTP.Response(200, ["Content-Type" => "application/json"], JSON.json(result))
                    end
                end

                # Special case for agents.get_agent_status command
                if command == "agents.get_agent_status"
                    @info "Handling agents.get_agent_status command directly"
                    # Check if required parameters are provided
                    agent_id = get(params, "agent_id", nothing)

                    if isnothing(agent_id)
                        error_response = Dict("success" => false, "error" => "Missing required parameter: agent_id")
                        return HTTP.Response(400, ["Content-Type" => "application/json"], JSON.json(error_response))
                    end

                    # Check if Agents module is available
                    if isdefined(JuliaOS, :Agents) && isdefined(JuliaOS.Agents, :getAgentStatus)
                        @info "Using JuliaOS.Agents.getAgentStatus"
                        status = JuliaOS.Agents.getAgentStatus(agent_id)

                        result = Dict(
                            "success" => true,
                            "data" => status
                        )
                        return HTTP.Response(200, ["Content-Type" => "application/json"], JSON.json(result))
                    else
                        @warn "JuliaOS.Agents module not available or getAgentStatus not defined, using mock implementation"
                        # Mock implementation for get_agent_status
                        status = Dict(
                            "id" => agent_id,
                            "name" => "Agent $agent_id",
                            "type" => "CUSTOM",
                            "status" => "RUNNING",
                            "uptime_seconds" => rand(1:3600),
                            "tasks_completed" => rand(0:100),
                            "queue_len" => rand(0:10),
                            "memory_size" => rand(0:1000),
                            "last_updated" => string(now() - Dates.Second(rand(1:3600)))
                        )

                        result = Dict(
                            "success" => true,
                            "data" => status
                        )
                        return HTTP.Response(200, ["Content-Type" => "application/json"], JSON.json(result))
                    end
                end

                # Special case for agents.get_metrics command
                if command == "agents.get_metrics"
                    @info "Handling agents.get_metrics command directly"
                    # Check if agent_id is provided
                    agent_id = get(params, "id", nothing)
                    if isnothing(agent_id)
                        error_response = Dict("success" => false, "error" => "Missing id for get_metrics")
                        return HTTP.Response(400, ["Content-Type" => "application/json"], JSON.json(error_response))
                    end

                    # Check if AgentSystem module is available
                    if isdefined(JuliaOS, :AgentSystem) && isdefined(JuliaOS.AgentSystem, :get_agent_metrics)
                        @info "Using JuliaOS.AgentSystem.get_agent_metrics"
                        metrics = JuliaOS.AgentSystem.get_agent_metrics(agent_id)
                        result = Dict("success" => true, "data" => metrics)
                        return HTTP.Response(200, ["Content-Type" => "application/json"], JSON.json(result))
                    else
                        @warn "JuliaOS.AgentSystem module not available or get_agent_metrics not defined, using mock implementation"
                        # Mock implementation for get_agent_metrics
                        metrics = Dict(
                            "tasks_completed" => rand(0:100),
                            "tasks_failed" => rand(0:10),
                            "messages_processed" => rand(0:500),
                            "errors" => rand(0:5),
                            "average_response_time" => rand(0.1:0.1:2.0),
                            "uptime" => rand(1:1000) * 60, # seconds
                            "memory_usage" => rand(1:100) # MB
                        )
                        result = Dict("success" => true, "data" => metrics)
                        return HTTP.Response(200, ["Content-Type" => "application/json"], JSON.json(result))
                    end
                end

                # Special case for swarms.list_swarms command
                if command == "swarms.list_swarms"
                    @info "Handling swarms.list_swarms command directly"
                    # Check if SwarmManager module is available
                    if isdefined(JuliaOS, :SwarmManager) && isdefined(JuliaOS.SwarmManager, :list_swarms)
                        @info "Using JuliaOS.SwarmManager.list_swarms"
                        swarms = JuliaOS.SwarmManager.list_swarms()

                        # Apply filters if specified
                        if haskey(params, "type")
                            swarms = filter(s -> s["type"] == params["type"], swarms)
                        end

                        if haskey(params, "status")
                            swarms = filter(s -> s["status"] == params["status"], swarms)
                        end

                        # Apply sorting
                        if haskey(params, "order_by") && params["order_by"] in ["created_at", "name", "status", "type"]
                            order_column = params["order_by"]
                            order_direction = get(params, "order_direction", "asc")

                            # Sort the swarms
                            if lowercase(order_direction) == "asc"
                                sort!(swarms, by = s -> s[order_column])
                            else
                                sort!(swarms, by = s -> s[order_column], rev = true)
                            end
                        end

                        # Apply pagination
                        limit = get(params, "limit", 100)
                        offset = get(params, "offset", 0)

                        # Ensure limit and offset are reasonable
                        limit = min(max(1, limit), 1000)  # Between 1 and 1000
                        offset = max(0, offset)           # At least 0

                        # Get total count before pagination
                        total = length(swarms)

                        # Apply pagination
                        if offset < total
                            end_idx = min(offset + limit, total)
                            swarms = swarms[offset+1:end_idx]
                        else
                            swarms = []
                        end

                        # Create the response
                        result = Dict(
                            "success" => true,
                            "data" => Dict(
                                "swarms" => swarms,
                                "pagination" => Dict(
                                    "total" => total,
                                    "limit" => limit,
                                    "offset" => offset
                                )
                            )
                        )

                        return HTTP.Response(200, ["Content-Type" => "application/json"], JSON.json(result))
                    else
                        @warn "JuliaOS.SwarmManager module not available or list_swarms not defined, using mock implementation"
                        # Mock implementation for list_swarms
                        swarms = [
                            Dict("id" => "swarm1", "name" => "Trading Swarm", "type" => "trading", "status" => "active", "created_at" => string(now() - Dates.Day(10))),
                            Dict("id" => "swarm2", "name" => "Data Swarm", "type" => "data", "status" => "inactive", "created_at" => string(now() - Dates.Day(5)))
                        ]

                        # Create the response
                        result = Dict(
                            "success" => true,
                            "data" => Dict(
                                "swarms" => swarms,
                                "pagination" => Dict(
                                    "total" => 2,
                                    "limit" => 100,
                                    "offset" => 0
                                )
                            )
                        )

                        return HTTP.Response(200, ["Content-Type" => "application/json"], JSON.json(result))
                    end
                end

                # Special case for swarms.get_swarm command
                if command == "swarms.get_swarm"
                    @info "Handling swarms.get_swarm command directly"
                    # Check if swarm_id is provided
                    swarm_id = get(params, "id", nothing)
                    if isnothing(swarm_id)
                        error_response = Dict("success" => false, "error" => "Missing id for get_swarm")
                        return HTTP.Response(400, ["Content-Type" => "application/json"], JSON.json(error_response))
                    end

                    # Check if SwarmManager module is available
                    if isdefined(JuliaOS, :SwarmManager) && isdefined(JuliaOS.SwarmManager, :get_swarm)
                        @info "Using JuliaOS.SwarmManager.get_swarm"
                        swarm = JuliaOS.SwarmManager.get_swarm(swarm_id)
                        if isnothing(swarm)
                            error_response = Dict("success" => false, "error" => "Swarm not found: $swarm_id")
                            return HTTP.Response(404, ["Content-Type" => "application/json"], JSON.json(error_response))
                        end

                        result = Dict("success" => true, "data" => swarm)
                        return HTTP.Response(200, ["Content-Type" => "application/json"], JSON.json(result))
                    else
                        @warn "JuliaOS.SwarmManager module not available or get_swarm not defined, using mock implementation"
                        # Mock implementation for get_swarm
                        if swarm_id == "swarm1"
                            swarm = Dict(
                                "id" => "swarm1",
                                "name" => "Trading Swarm",
                                "type" => "trading",
                                "status" => "active",
                                "created_at" => string(now() - Dates.Day(10)),
                                "last_update" => string(now() - Dates.Hour(2)),
                                "agents" => [
                                    Dict("id" => "agent1", "name" => "Trading Agent 1", "role" => "trader"),
                                    Dict("id" => "agent2", "name" => "Data Agent 1", "role" => "data_collector")
                                ],
                                "config" => Dict(
                                    "max_agents" => 10,
                                    "communication_mode" => "broadcast",
                                    "decision_algorithm" => "majority_vote"
                                )
                            )
                            result = Dict("success" => true, "data" => swarm)
                            return HTTP.Response(200, ["Content-Type" => "application/json"], JSON.json(result))
                        elseif swarm_id == "swarm2"
                            swarm = Dict(
                                "id" => "swarm2",
                                "name" => "Data Swarm",
                                "type" => "data",
                                "status" => "inactive",
                                "created_at" => string(now() - Dates.Day(5)),
                                "last_update" => string(now() - Dates.Hour(12)),
                                "agents" => [
                                    Dict("id" => "agent3", "name" => "Data Agent 2", "role" => "data_collector"),
                                    Dict("id" => "agent4", "name" => "Analysis Agent", "role" => "analyzer")
                                ],
                                "config" => Dict(
                                    "max_agents" => 5,
                                    "communication_mode" => "p2p",
                                    "decision_algorithm" => "weighted_vote"
                                )
                            )
                            result = Dict("success" => true, "data" => swarm)
                            return HTTP.Response(200, ["Content-Type" => "application/json"], JSON.json(result))
                        else
                            error_response = Dict("success" => false, "error" => "Swarm not found: $swarm_id")
                            return HTTP.Response(404, ["Content-Type" => "application/json"], JSON.json(error_response))
                        end
                    end
                end

                # Special case for blockchain.list_networks command
                if command == "blockchain.list_networks"
                    @info "Handling blockchain.list_networks command directly"
                    # Check if Blockchain module is available
                    if isdefined(JuliaOS, :Blockchain) && isdefined(JuliaOS.Blockchain, :ACTIVE_CONNECTIONS)
                        @info "Using JuliaOS.Blockchain.ACTIVE_CONNECTIONS"
                        networks = []

                        for (name, connection) in JuliaOS.Blockchain.ACTIVE_CONNECTIONS
                            push!(networks, Dict(
                                "name" => name,
                                "chain_id" => connection.config.chain_id,
                                "rpc_url" => connection.config.rpc_url,
                                "native_currency" => connection.config.native_currency,
                                "is_connected" => connection.is_connected,
                                "last_block" => connection.last_block_number
                            ))
                        end

                        result = Dict(
                            "success" => true,
                            "data" => Dict(
                                "networks" => networks,
                                "count" => length(networks)
                            )
                        )
                        return HTTP.Response(200, ["Content-Type" => "application/json"], JSON.json(result))
                    else
                        @warn "JuliaOS.Blockchain module not available or ACTIVE_CONNECTIONS not defined, using mock implementation"
                        # Mock implementation for list_networks
                        mock_networks = [
                            Dict(
                                "name" => "ethereum",
                                "chain_id" => 1,
                                "rpc_url" => "https://mainnet.infura.io/v3/your-api-key",
                                "native_currency" => "ETH",
                                "is_connected" => true,
                                "last_block" => rand(10000000:20000000)
                            ),
                            Dict(
                                "name" => "polygon",
                                "chain_id" => 137,
                                "rpc_url" => "https://polygon-rpc.com",
                                "native_currency" => "MATIC",
                                "is_connected" => true,
                                "last_block" => rand(30000000:40000000)
                            )
                        ]
                        result = Dict(
                            "success" => true,
                            "data" => Dict(
                                "networks" => mock_networks,
                                "count" => length(mock_networks)
                            )
                        )
                        return HTTP.Response(200, ["Content-Type" => "application/json"], JSON.json(result))
                    end
                end

                # Special case for blockchain.connect command
                if command == "blockchain.connect"
                    @info "Handling blockchain.connect command directly"
                    # Check if required parameters are provided
                    network_name = get(params, "network", nothing)
                    rpc_url = get(params, "rpc_url", nothing)

                    if isnothing(network_name) || isnothing(rpc_url)
                        error_response = Dict("success" => false, "error" => "Missing required parameters for connect: network and rpc_url required")
                        return HTTP.Response(400, ["Content-Type" => "application/json"], JSON.json(error_response))
                    end

                    # Get optional parameters
                    ws_url = get(params, "ws_url", "")
                    chain_id = get(params, "chain_id", 1)
                    native_currency = get(params, "native_currency", "ETH")
                    block_time = get(params, "block_time", 15)
                    confirmations_required = get(params, "confirmations_required", 12)
                    max_gas_price = get(params, "max_gas_price", 100000000000)  # 100 gwei
                    max_priority_fee = get(params, "max_priority_fee", 2000000000)  # 2 gwei

                    # Check if Blockchain module is available
                    if false && isdefined(JuliaOS, :Blockchain) && isdefined(JuliaOS.Blockchain, :connect_to_chain)
                        @info "Using JuliaOS.Blockchain.connect_to_chain"

                        # Create blockchain config
                        config = JuliaOS.Blockchain.BlockchainConfig(
                            chain_id,
                            rpc_url,
                            ws_url,
                            network_name,
                            native_currency,
                            block_time,
                            confirmations_required,
                            max_gas_price,
                            max_priority_fee
                        )

                        # Connect to chain
                        connection = JuliaOS.Blockchain.connect_to_chain(config)

                        if connection !== nothing
                            result = Dict(
                                "success" => true,
                                "data" => Dict(
                                    "network" => network_name,
                                    "connected" => true,
                                    "chain_id" => chain_id,
                                    "native_currency" => native_currency
                                )
                            )
                            return HTTP.Response(200, ["Content-Type" => "application/json"], JSON.json(result))
                        else
                            error_response = Dict("success" => false, "error" => "Failed to connect to $network_name")
                            return HTTP.Response(500, ["Content-Type" => "application/json"], JSON.json(error_response))
                        end
                    else
                        @warn "JuliaOS.Blockchain module not available or connect_to_chain not defined, using mock implementation"
                        # Mock implementation for connect
                        result = Dict(
                            "success" => true,
                            "data" => Dict(
                                "network" => network_name,
                                "connected" => true,
                                "chain_id" => chain_id,
                                "native_currency" => native_currency
                            )
                        )
                        return HTTP.Response(200, ["Content-Type" => "application/json"], JSON.json(result))
                    end
                end

                # Special case for storage.health command
                if command == "storage.health"
                    @info "Handling storage.health command directly"
                    try
                        # Check if Storage module is available
                        if isdefined(JuliaOS, :Storage) && isdefined(JuliaOS.Storage, :check_health)
                            @info "Using JuliaOS.Storage.check_health"
                            health = JuliaOS.Storage.check_health()
                            result = Dict("success" => true, "data" => health)
                            return HTTP.Response(200, ["Content-Type" => "application/json"], JSON.json(result))
                        else
                            @warn "JuliaOS.Storage module not available or check_health not defined, using mock implementation"
                            # Mock implementation for health check
                            health = Dict(
                                "status" => "healthy",
                                "db_path" => joinpath(homedir(), ".juliaos", "juliaos.sqlite"),
                                "cache" => Dict(
                                    "agent_cache_size" => 0,
                                    "query_cache_size" => 0,
                                    "hits" => 0,
                                    "misses" => 0,
                                    "inserts" => 0,
                                    "evictions" => 0,
                                    "invalidations" => 0
                                ),
                                "timestamp" => string(now())
                            )
                            result = Dict("success" => true, "data" => health)
                            return HTTP.Response(200, ["Content-Type" => "application/json"], JSON.json(result))
                        end
                    catch e
                        @error "Error checking storage health" exception=(e, catch_backtrace())
                        error_response = Dict("success" => false, "error" => "Error checking storage health: $(string(e))")
                        return HTTP.Response(500, ["Content-Type" => "application/json"], JSON.json(error_response))
                    end
                end

                # Special case for storage.set command
                if command == "storage.set"
                    @info "Handling storage.set command directly"
                    # Check if required parameters are provided
                    key = get(params, "key", nothing)
                    value = get(params, "value", nothing)

                    if isnothing(key) || isnothing(value)
                        error_response = Dict("success" => false, "error" => "Missing key or value for set")
                        return HTTP.Response(400, ["Content-Type" => "application/json"], JSON.json(error_response))
                    end

                    try
                        # Check if Storage module is available
                        if isdefined(JuliaOS, :Storage) && isdefined(JuliaOS.Storage, :get_storage)
                            @info "Using JuliaOS.Storage.get_storage"
                            storage = JuliaOS.Storage.get_storage()
                            storage[key] = value

                            result = Dict("success" => true, "data" => Dict("key" => key, "value" => value))
                            return HTTP.Response(200, ["Content-Type" => "application/json"], JSON.json(result))
                        else
                            @warn "JuliaOS.Storage module not available or get_storage not defined, using mock implementation"
                            # Mock implementation for set
                            result = Dict("success" => true, "data" => Dict("key" => key, "value" => value))
                            return HTTP.Response(200, ["Content-Type" => "application/json"], JSON.json(result))
                        end
                    catch e
                        @error "Error setting value in storage" exception=(e, catch_backtrace())
                        error_response = Dict("success" => false, "error" => "Error setting value in storage: $(string(e))")
                        return HTTP.Response(500, ["Content-Type" => "application/json"], JSON.json(error_response))
                    end
                end

                # Special case for storage.get command
                if command == "storage.get"
                    @info "Handling storage.get command directly"
                    # Check if required parameters are provided
                    key = get(params, "key", nothing)

                    if isnothing(key)
                        error_response = Dict("success" => false, "error" => "Missing key for get")
                        return HTTP.Response(400, ["Content-Type" => "application/json"], JSON.json(error_response))
                    end

                    try
                        # Check if Storage module is available
                        if isdefined(JuliaOS, :Storage) && isdefined(JuliaOS.Storage, :get_storage)
                            @info "Using JuliaOS.Storage.get_storage"
                            storage = JuliaOS.Storage.get_storage()

                            if haskey(storage, key)
                                result = Dict("success" => true, "data" => Dict("key" => key, "value" => storage[key]))
                                return HTTP.Response(200, ["Content-Type" => "application/json"], JSON.json(result))
                            else
                                error_response = Dict("success" => false, "error" => "Key not found: $key")
                                return HTTP.Response(404, ["Content-Type" => "application/json"], JSON.json(error_response))
                            end
                        else
                            @warn "JuliaOS.Storage module not available or get_storage not defined, using mock implementation"
                            # Mock implementation for get
                            if key == "test_key"
                                result = Dict("success" => true, "data" => Dict("key" => key, "value" => "test_value"))
                                return HTTP.Response(200, ["Content-Type" => "application/json"], JSON.json(result))
                            else
                                error_response = Dict("success" => false, "error" => "Key not found: $key")
                                return HTTP.Response(404, ["Content-Type" => "application/json"], JSON.json(error_response))
                            end
                        end
                    catch e
                        @error "Error getting value from storage" exception=(e, catch_backtrace())
                        error_response = Dict("success" => false, "error" => "Error getting value from storage: $(string(e))")
                        return HTTP.Response(500, ["Content-Type" => "application/json"], JSON.json(error_response))
                    end
                end

                # Special case for dex.connect command
                if command == "dex.connect"
                    @info "Handling dex.connect command directly"
                    # Check if required parameters are provided
                    dex_name = get(params, "name", nothing)
                    version = get(params, "version", nothing)
                    network = get(params, "network", nothing)
                    router_address = get(params, "router_address", nothing)
                    factory_address = get(params, "factory_address", nothing)

                    if isnothing(dex_name) || isnothing(version) || isnothing(network) || isnothing(router_address) || isnothing(factory_address)
                        error_response = Dict("success" => false, "error" => "Missing required parameters for connect")
                        return HTTP.Response(400, ["Content-Type" => "application/json"], JSON.json(error_response))
                    end

                    # Get optional parameters
                    weth_address = get(params, "weth_address", "0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2")  # Default to Ethereum WETH
                    router_abi = get(params, "router_abi", [])
                    factory_abi = get(params, "factory_abi", [])
                    pair_abi = get(params, "pair_abi", [])
                    token_abi = get(params, "token_abi", [])
                    gas_limit = get(params, "gas_limit", 200000)
                    gas_price = get(params, "gas_price", 50000000000)  # 50 gwei
                    slippage_tolerance = get(params, "slippage_tolerance", 0.005)  # 0.5%

                    try
                        # Check if DEX module is available
                        if false && isdefined(JuliaOS, :DEX) && isdefined(JuliaOS.DEX, :connect_to_dex)
                            @info "Using JuliaOS.DEX.connect_to_dex"

                            # Create DEX config
                            config = JuliaOS.DEX.DEXConfig(
                                dex_name,
                                version,
                                network,
                                router_address,
                                factory_address,
                                weth_address,
                                router_abi,
                                factory_abi,
                                pair_abi,
                                token_abi,
                                gas_limit,
                                gas_price,
                                slippage_tolerance
                            )

                            # Connect to DEX
                            instance = JuliaOS.DEX.connect_to_dex(config)

                            if instance !== nothing
                                result = Dict(
                                    "success" => true,
                                    "data" => Dict(
                                        "name" => dex_name,
                                        "version" => version,
                                        "network" => network,
                                        "router_address" => router_address,
                                        "factory_address" => factory_address,
                                        "connected" => true
                                    )
                                )
                                return HTTP.Response(200, ["Content-Type" => "application/json"], JSON.json(result))
                            else
                                error_response = Dict("success" => false, "error" => "Failed to connect to DEX: $dex_name")
                                return HTTP.Response(500, ["Content-Type" => "application/json"], JSON.json(error_response))
                            end
                        else
                            @warn "JuliaOS.DEX module not available or connect_to_dex not defined, using mock implementation"
                            # Mock implementation for connect
                            result = Dict(
                                "success" => true,
                                "data" => Dict(
                                    "name" => dex_name,
                                    "version" => version,
                                    "network" => network,
                                    "router_address" => router_address,
                                    "factory_address" => factory_address,
                                    "connected" => true
                                )
                            )
                            return HTTP.Response(200, ["Content-Type" => "application/json"], JSON.json(result))
                        end
                    catch e
                        @error "Error connecting to DEX" exception=(e, catch_backtrace())
                        error_response = Dict("success" => false, "error" => "Error connecting to DEX: $(string(e))")
                        return HTTP.Response(500, ["Content-Type" => "application/json"], JSON.json(error_response))
                    end
                end

                # Special case for dex.list_dexes command
                if command == "dex.list_dexes"
                    @info "Handling dex.list_dexes command directly"
                    try
                        # Check if DEX module is available
                        if isdefined(JuliaOS, :DEX) && isdefined(JuliaOS.DEX, :DEX_INSTANCES)
                            @info "Using JuliaOS.DEX.DEX_INSTANCES"
                            dexes = []

                            for (name, instance) in JuliaOS.DEX.DEX_INSTANCES
                                push!(dexes, Dict(
                                    "name" => name,
                                    "version" => instance.config.version,
                                    "network" => instance.config.network,
                                    "router_address" => instance.config.router_address,
                                    "factory_address" => instance.config.factory_address
                                ))
                            end

                            result = Dict(
                                "success" => true,
                                "data" => Dict(
                                    "dexes" => dexes,
                                    "count" => length(dexes)
                                )
                            )
                            return HTTP.Response(200, ["Content-Type" => "application/json"], JSON.json(result))
                        else
                            @warn "JuliaOS.DEX module not available or DEX_INSTANCES not defined, using mock implementation"
                            # Mock implementation for list_dexes
                            mock_dexes = [
                                Dict(
                                    "name" => "uniswap_v3",
                                    "version" => "3.0.0",
                                    "network" => "ethereum",
                                    "router_address" => "0xE592427A0AEce92De3Edee1F18E0157C05861564",
                                    "factory_address" => "0x1F98431c8aD98523631AE4a59f267346ea31F984"
                                ),
                                Dict(
                                    "name" => "sushiswap",
                                    "version" => "1.0.0",
                                    "network" => "ethereum",
                                    "router_address" => "0xd9e1cE17f2641f24aE83637ab66a2cca9C378B9F",
                                    "factory_address" => "0xC0AEe478e3658e2610c5F7A4A2E1777cE9e4f2Ac"
                                )
                            ]
                            result = Dict(
                                "success" => true,
                                "data" => Dict(
                                    "dexes" => mock_dexes,
                                    "count" => length(mock_dexes)
                                )
                            )
                            return HTTP.Response(200, ["Content-Type" => "application/json"], JSON.json(result))
                        end
                    catch e
                        @error "Error listing DEXes" exception=(e, catch_backtrace())
                        error_response = Dict("success" => false, "error" => "Error listing DEXes: $(string(e))")
                        return HTTP.Response(500, ["Content-Type" => "application/json"], JSON.json(error_response))
                    end
                end

                # Special case for WormholeBridge.get_available_chains command
                if command == "WormholeBridge.get_available_chains"
                    @info "Handling WormholeBridge.get_available_chains command directly"
                    try
                        # Check if WormholeBridge module is available
                        if isdefined(JuliaOS, :WormholeBridge) && isdefined(JuliaOS.WormholeBridge, :get_available_chains)
                            @info "Using JuliaOS.WormholeBridge.get_available_chains"
                            result = JuliaOS.WormholeBridge.get_available_chains()

                            if result["success"]
                                # Format the chains to match the expected format
                                formatted_chains = []
                                for chain in result["chains"]
                                    push!(formatted_chains, Dict(
                                        "id" => chain["id"],
                                        "name" => chain["name"],
                                        "symbol" => uppercase(chain["id"]),
                                        "wormhole_id" => chain["chainId"]
                                    ))
                                end

                                response = Dict("success" => true, "data" => Dict("chains" => formatted_chains))
                                return HTTP.Response(200, ["Content-Type" => "application/json"], JSON.json(response))
                            else
                                error_response = Dict("success" => false, "error" => get(result, "error", "Unknown error getting available chains"))
                                return HTTP.Response(500, ["Content-Type" => "application/json"], JSON.json(error_response))
                            end
                        else
                            @warn "JuliaOS.WormholeBridge module not available or get_available_chains not defined"
                            error_response = Dict("success" => false, "error" => "Wormhole Bridge is not available. The WormholeBridge module is not loaded or the get_available_chains function is not defined.")
                            return HTTP.Response(503, ["Content-Type" => "application/json"], JSON.json(error_response))
                        end
                    catch e
                        @error "Error getting available chains" exception=(e, catch_backtrace())
                        error_response = Dict("success" => false, "error" => "Error getting available chains: $(string(e))")
                        return HTTP.Response(500, ["Content-Type" => "application/json"], JSON.json(error_response))
                    end
                end

                # Special case for WormholeBridge.get_available_tokens command
                if command == "WormholeBridge.get_available_tokens"
                    @info "Handling WormholeBridge.get_available_tokens command directly"
                    chain_id = get(params, "chain_id", nothing)
                    chain = get(params, "chain", nothing)

                    # If chain_id is provided but chain is not, convert chain_id to chain name
                    if !isnothing(chain_id) && isnothing(chain)
                        # Map chain_id to chain name
                        chain_map = Dict(
                            1 => "ethereum",
                            56 => "bsc",
                            137 => "polygon",
                            43114 => "avalanche",
                            42161 => "arbitrum",
                            10 => "optimism",
                            8453 => "base",
                            1 => "solana"
                        )

                        chain = get(chain_map, chain_id, nothing)
                    end

                    if isnothing(chain)
                        error_response = Dict("success" => false, "error" => "Missing chain parameter for get_available_tokens")
                        return HTTP.Response(400, ["Content-Type" => "application/json"], JSON.json(error_response))
                    end

                    try
                        # Check if WormholeBridge module is available
                        if isdefined(JuliaOS, :WormholeBridge) && isdefined(JuliaOS.WormholeBridge, :get_available_tokens)
                            @info "Using JuliaOS.WormholeBridge.get_available_tokens"
                            result = JuliaOS.WormholeBridge.get_available_tokens(chain)

                            if result["success"]
                                # Format the tokens to match the expected format
                                formatted_tokens = []
                                for token in result["tokens"]
                                    push!(formatted_tokens, Dict(
                                        "symbol" => token["symbol"],
                                        "name" => token["name"],
                                        "address" => token["address"],
                                        "decimals" => token["decimals"]
                                    ))
                                end

                                response = Dict("success" => true, "data" => Dict("tokens" => formatted_tokens, "chain_id" => chain_id, "chain" => chain))
                                return HTTP.Response(200, ["Content-Type" => "application/json"], JSON.json(response))
                            else
                                error_response = Dict("success" => false, "error" => get(result, "error", "Unknown error getting available tokens"))
                                return HTTP.Response(500, ["Content-Type" => "application/json"], JSON.json(error_response))
                            end
                        else
                            @warn "JuliaOS.WormholeBridge module not available or get_available_tokens not defined"
                            error_response = Dict("success" => false, "error" => "Wormhole Bridge is not available. The WormholeBridge module is not loaded or the get_available_tokens function is not defined.")
                            return HTTP.Response(503, ["Content-Type" => "application/json"], JSON.json(error_response))
                        end
                    catch e
                        @error "Error getting available tokens" exception=(e, catch_backtrace())
                        error_response = Dict("success" => false, "error" => "Error getting available tokens: $(string(e))")
                        return HTTP.Response(500, ["Content-Type" => "application/json"], JSON.json(error_response))
                    end
                end

                # Try to handle the command using the Bridge module directly
                try
                    if isdefined(JuliaOS, :Bridge) && isdefined(JuliaOS.Bridge, :handle_command)
                        # Use Bridge's handle_command function
                        @info "Using Bridge.handle_command for command: $command"
                        result = JuliaOS.Bridge.handle_command(command, params)
                        return HTTP.Response(200, ["Content-Type" => "application/json"], JSON.json(result))
                    # Try to handle the command using the CommandHandler module
                    elseif isdefined(JuliaOS, :CommandHandler) && isdefined(JuliaOS.CommandHandler, :handle_command)
                        # Call the handle_command function
                        @info "Using CommandHandler.handle_command for command: $command"
                        result = JuliaOS.CommandHandler.handle_command(command, params)
                        # Return the result as JSON
                        return HTTP.Response(200, ["Content-Type" => "application/json"], JSON.json(result))
                    else
                        # Fallback to a simple response if CommandHandler is not available
                        @warn "CommandHandler module not available or handle_command function not defined. Returning simple response."
                        # Try to use the command_handler.jl directly if available
                        if isdefined(Main, :handle_command)
                            @info "Using Main.handle_command for command: $command"
                            result = Main.handle_command(command, params)
                            return HTTP.Response(200, ["Content-Type" => "application/json"], JSON.json(result))
                        else
                            # Create a simple mock response
                            mock_response = Dict(
                                "success" => true,
                                "data" => Dict(
                                    "message" => "Command $command received",
                                    "timestamp" => string(now()),
                                    "mock" => true
                                )
                            )
                            return HTTP.Response(200, ["Content-Type" => "application/json"], JSON.json(mock_response))
                        end
                    end
                catch e
                    # Log the error and return a detailed error response
                    @error "Error handling command $command" exception=(e, catch_backtrace())
                    error_msg = "Error handling command: $(typeof(e))"

                    # Try to extract the error message in a safe way
                    try
                        if isdefined(e, :msg)
                            error_msg = "$error_msg: $(e.msg)"
                        elseif isdefined(e, :message)
                            error_msg = "$error_msg: $(e.message)"
                        else
                            error_msg = "$error_msg: $(string(e))"
                        end
                    catch
                        error_msg = "$error_msg: (Could not extract detailed error message)"
                    end

                    # Update the global state with the last error
                    GLOBAL_STATE["last_error"] = Dict(
                        "timestamp" => now(),
                        "command" => command,
                        "error" => error_msg
                    )

                    return HTTP.Response(500, ["Content-Type" => "application/json"], "{\"success\": false, \"error\": \"$error_msg\"}")
                end
            catch e
                # Handle errors in parsing the request
                @error "Error processing request" exception=(e, catch_backtrace())
                error_msg = "Error processing request: $(typeof(e))"

                # Try to extract the error message in a safe way
                try
                    if isdefined(e, :msg)
                        error_msg = "$error_msg: $(e.msg)"
                    elseif isdefined(e, :message)
                        error_msg = "$error_msg: $(e.message)"
                    else
                        error_msg = "$error_msg: $(string(e))"
                    end
                catch
                    error_msg = "$error_msg: (Could not extract detailed error message)"
                end

                # Update the global state with the last error
                GLOBAL_STATE["last_error"] = Dict(
                    "timestamp" => now(),
                    "error" => error_msg
                )

                return HTTP.Response(400, ["Content-Type" => "application/json"], "{\"success\": false, \"error\": \"$error_msg\"}")
            end
        end)

        # Start the server
        @info "Starting simple HTTP server on $(config.server.host):$(config.server.port)"
        # Convert hostname to IP if needed
        host_ip = config.server.host == "localhost" ? "127.0.0.1" : config.server.host
        server = HTTP.serve!(router, host_ip, config.server.port)
        @info "Simple HTTP server started successfully"

        # Keep the script running
        wait(server)
    end

    @info "Server has stopped. Exiting."
catch e
    @error "Error starting JuliaOS server: $e" exception=(e, catch_backtrace())
    exit(1)
end
